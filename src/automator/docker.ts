import { execaCommand } from 'execa';
import { writeFile, readFile, mkdir, unlink } from 'node:fs/promises';
import { existsSync } from 'node:fs';
import { join } from 'node:path';
import { TypedEventEmitter } from '../core/events.js';
import { createLogger } from '../core/logger.js';
import { HieroBridgeError, ErrorCode } from '../types/errors.js';
import type pino from 'pino';

// ---------------------------------------------------------------------------
// Types
// ---------------------------------------------------------------------------

export interface DockerManagerConfig {
  /** Directory to store generated docker-compose files. Default: `.hiero`. */
  workDir?: string;
  /** Project name for Docker Compose. Default: `hiero-block-node`. */
  projectName?: string;
  /** Block Node gRPC port. Default: 8080. */
  grpcPort?: number;
  /** Block Node REST API port. Default: 8081. */
  restPort?: number;
  /** Mirror Node REST port. Default: 5551. */
  mirrorPort?: number;
  /** Additional environment variables for the Block Node container. */
  env?: Record<string, string>;
  /** Additional volume mounts (host:container format). */
  volumes?: string[];
  /** Docker Compose command override (e.g., `docker compose` vs `docker-compose`). */
  composeCommand?: string;
  logger?: pino.Logger;
}

export interface ContainerStatus {
  name: string;
  state: 'running' | 'exited' | 'restarting' | 'paused' | 'created' | 'unknown';
  health: 'healthy' | 'unhealthy' | 'starting' | 'none' | 'unknown';
  ports: string;
  uptime: string;
}

export interface DockerManagerEvents {
  containerUp: (projectName: string) => void;
  containerDown: (projectName: string) => void;
  healthCheckPass: (url: string) => void;
  healthCheckFail: (url: string, error: Error) => void;
  composeGenerated: (path: string) => void;
  error: (error: Error) => void;
}

// ---------------------------------------------------------------------------
// Docker Compose template
// ---------------------------------------------------------------------------

function generateComposeYaml(config: Required<DockerManagerConfig>): string {
  const envBlock = Object.entries(config.env)
    .map(([k, v]) => `      ${k}: "${v}"`)
    .join('\n');

  const volumeBlock = config.volumes
    .map((v) => `      - ${v}`)
    .join('\n');

  return `# Generated by HieroBlockBridge DockerManager
# Do not edit manually â€” regenerate via DockerManager.generateCompose()

version: "3.8"

services:
  block-node:
    image: ghcr.io/hiero-ledger/hiero-block-node:latest
    container_name: ${config.projectName}-block-node
    ports:
      - "${config.grpcPort}:8080"
      - "${config.restPort}:8081"
    environment:
      JAVA_OPTS: "-Xmx512m"
      HIERO_BLOCK_NODE_STORAGE_ROOT: "/opt/hiero/data"
${envBlock ? `${envBlock}\n` : ''}    volumes:
      - block-node-data:/opt/hiero/data
${volumeBlock ? `${volumeBlock}\n` : ''}    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 10s
      timeout: 5s
      retries: 10
      start_period: 30s
    restart: unless-stopped

  mirror-node:
    image: ghcr.io/hiero-ledger/hedera-mirror-node:latest
    container_name: ${config.projectName}-mirror-node
    ports:
      - "${config.mirrorPort}:5551"
    environment:
      HEDERA_MIRROR_IMPORTER_ENABLED: "true"
    depends_on:
      block-node:
        condition: service_healthy
    restart: unless-stopped

volumes:
  block-node-data:
    driver: local
`;
}

// ---------------------------------------------------------------------------
// DockerManager
// ---------------------------------------------------------------------------

/**
 * Manages Docker Compose lifecycle for local Block Node environments.
 * Generates compose files, starts/stops containers, and polls health.
 */
export class DockerManager extends TypedEventEmitter<DockerManagerEvents> {
  private readonly config: Required<DockerManagerConfig>;
  private readonly logger: pino.Logger;
  private composePath: string;

  constructor(config?: DockerManagerConfig) {
    super();

    this.config = {
      workDir: config?.workDir ?? '.hiero',
      projectName: config?.projectName ?? 'hiero-block-node',
      grpcPort: config?.grpcPort ?? 8080,
      restPort: config?.restPort ?? 8081,
      mirrorPort: config?.mirrorPort ?? 5551,
      env: config?.env ?? {},
      volumes: config?.volumes ?? [],
      composeCommand: config?.composeCommand ?? 'docker compose',
      logger: config?.logger ?? createLogger({ level: 'info' }),
    };

    this.logger = this.config.logger;
    this.composePath = join(this.config.workDir, 'docker-compose.yml');
  }

  // -----------------------------------------------------------------------
  // Compose file management
  // -----------------------------------------------------------------------

  /** Generate a `docker-compose.yml` in the work directory. */
  async generateCompose(): Promise<string> {
    const yaml = generateComposeYaml(this.config);

    if (!existsSync(this.config.workDir)) {
      await mkdir(this.config.workDir, { recursive: true });
    }

    await writeFile(this.composePath, yaml, 'utf-8');
    this.emit('composeGenerated', this.composePath);
    this.logger.info({ path: this.composePath }, 'docker-compose.yml generated');

    return this.composePath;
  }

  /** Read the current docker-compose.yml contents. */
  async getCompose(): Promise<string> {
    if (!existsSync(this.composePath)) {
      throw new HieroBridgeError(
        ErrorCode.DOCKER_NOT_FOUND,
        `No compose file at ${this.composePath}. Run generateCompose() first.`,
      );
    }
    return readFile(this.composePath, 'utf-8');
  }

  /** Remove the generated docker-compose.yml. */
  async cleanCompose(): Promise<void> {
    if (existsSync(this.composePath)) {
      await unlink(this.composePath);
      this.logger.info({ path: this.composePath }, 'docker-compose.yml removed');
    }
  }

  // -----------------------------------------------------------------------
  // Container lifecycle
  // -----------------------------------------------------------------------

  /** Start containers in detached mode. Generates compose file if missing. */
  async up(): Promise<void> {
    if (!existsSync(this.composePath)) {
      await this.generateCompose();
    }

    try {
      await this.compose('up -d');
      this.emit('containerUp', this.config.projectName);
      this.logger.info({ project: this.config.projectName }, 'Containers started');
    } catch (error) {
      throw this.wrapDockerError('up', error);
    }
  }

  /** Stop and remove containers. */
  async down(): Promise<void> {
    try {
      await this.compose('down');
      this.emit('containerDown', this.config.projectName);
      this.logger.info({ project: this.config.projectName }, 'Containers stopped');
    } catch (error) {
      throw this.wrapDockerError('down', error);
    }
  }

  /** Restart all containers. */
  async restart(): Promise<void> {
    try {
      await this.compose('restart');
      this.logger.info({ project: this.config.projectName }, 'Containers restarted');
    } catch (error) {
      throw this.wrapDockerError('restart', error);
    }
  }

  /** Stop containers without removing them. */
  async stop(): Promise<void> {
    try {
      await this.compose('stop');
      this.logger.info({ project: this.config.projectName }, 'Containers stopped');
    } catch (error) {
      throw this.wrapDockerError('stop', error);
    }
  }

  /** Fetch container logs. */
  async logs(options?: { tail?: number; follow?: boolean; service?: string }): Promise<string> {
    const args: string[] = ['logs'];
    if (options?.tail !== undefined) args.push(`--tail=${options.tail}`);
    if (!options?.follow) args.push('--no-log-prefix');
    if (options?.service) args.push(options.service);

    try {
      const result = await this.compose(args.join(' '));
      return result;
    } catch (error) {
      throw this.wrapDockerError('logs', error);
    }
  }

  /** Get status of all containers in the project. */
  async status(): Promise<ContainerStatus[]> {
    try {
      const output = await this.compose('ps --format json');
      const lines = output.trim().split('\n').filter(Boolean);

      return lines.map((line) => {
        try {
          const parsed = JSON.parse(line) as Record<string, string>;
          return {
            name: parsed['Name'] ?? parsed['name'] ?? 'unknown',
            state: mapState(parsed['State'] ?? parsed['state'] ?? ''),
            health: mapHealth(parsed['Health'] ?? parsed['health'] ?? ''),
            ports: parsed['Ports'] ?? parsed['ports'] ?? '',
            uptime: parsed['RunningFor'] ?? parsed['running_for'] ?? '',
          };
        } catch {
          return {
            name: 'unknown',
            state: 'unknown' as const,
            health: 'unknown' as const,
            ports: '',
            uptime: '',
          };
        }
      });
    } catch (error) {
      throw this.wrapDockerError('status', error);
    }
  }

  // -----------------------------------------------------------------------
  // Health check polling
  // -----------------------------------------------------------------------

  /**
   * Wait for the Block Node to become healthy.
   *
   * @param timeoutMs - Maximum time to wait. Default: 120_000 (2 minutes).
   * @param intervalMs - Polling interval. Default: 3_000 (3 seconds).
   */
  async waitForHealthy(timeoutMs = 120_000, intervalMs = 3_000): Promise<void> {
    const url = `http://localhost:${this.config.restPort}/health`;
    const deadline = Date.now() + timeoutMs;

    this.logger.info({ url, timeoutMs }, 'Waiting for Block Node health');

    while (Date.now() < deadline) {
      try {
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 5_000);

        const response = await fetch(url, { signal: controller.signal });
        clearTimeout(timeout);

        if (response.ok) {
          this.emit('healthCheckPass', url);
          this.logger.info({ url }, 'Block Node is healthy');
          return;
        }
      } catch {
        // Not ready yet
      }

      this.logger.debug({ url }, 'Health check pending, retrying...');
      await sleep(intervalMs);
    }

    const error = new Error(`Block Node did not become healthy within ${timeoutMs}ms`);
    this.emit('healthCheckFail', url, error);
    throw new HieroBridgeError(
      ErrorCode.HEALTH_CHECK_TIMEOUT,
      error.message,
      { url, timeoutMs },
    );
  }

  // -----------------------------------------------------------------------
  // Docker availability check
  // -----------------------------------------------------------------------

  /** Check if Docker is installed and the daemon is running. */
  async checkDocker(): Promise<{ available: boolean; version?: string; error?: string }> {
    try {
      const { stdout } = await execaCommand('docker version --format "{{.Server.Version}}"');
      return { available: true, version: stdout.trim() };
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      return { available: false, error: message };
    }
  }

  // -----------------------------------------------------------------------
  // Accessors
  // -----------------------------------------------------------------------

  getProjectName(): string {
    return this.config.projectName;
  }

  getComposePath(): string {
    return this.composePath;
  }

  getPorts(): { grpc: number; rest: number; mirror: number } {
    return {
      grpc: this.config.grpcPort,
      rest: this.config.restPort,
      mirror: this.config.mirrorPort,
    };
  }

  // -----------------------------------------------------------------------
  // Internal
  // -----------------------------------------------------------------------

  /** Execute a Docker Compose command and return stdout. */
  private async compose(subcommand: string): Promise<string> {
    const cmd = `${this.config.composeCommand} -f ${this.composePath} -p ${this.config.projectName} ${subcommand}`;
    this.logger.debug({ cmd }, 'Executing docker compose');

    const { stdout } = await execaCommand(cmd);
    return stdout;
  }

  private wrapDockerError(operation: string, error: unknown): HieroBridgeError {
    const message = error instanceof Error ? error.message : String(error);

    if (message.includes('not found') || message.includes('not recognized')) {
      return new HieroBridgeError(
        ErrorCode.DOCKER_NOT_FOUND,
        `Docker not found. Install Docker Desktop or Docker Engine to use the automator.`,
        { operation },
      );
    }

    return new HieroBridgeError(
      ErrorCode.DOCKER_COMPOSE_FAILED,
      `docker compose ${operation} failed: ${message}`,
      { operation },
    );
  }
}

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

function mapState(state: string): ContainerStatus['state'] {
  const s = state.toLowerCase();
  if (s.includes('running')) return 'running';
  if (s.includes('exited')) return 'exited';
  if (s.includes('restarting')) return 'restarting';
  if (s.includes('paused')) return 'paused';
  if (s.includes('created')) return 'created';
  return 'unknown';
}

function mapHealth(health: string): ContainerStatus['health'] {
  const h = health.toLowerCase();
  if (h.includes('healthy') && !h.includes('unhealthy')) return 'healthy';
  if (h.includes('unhealthy')) return 'unhealthy';
  if (h.includes('starting')) return 'starting';
  if (h === '' || h === 'none') return 'none';
  return 'unknown';
}
